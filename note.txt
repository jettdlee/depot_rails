s

String Literal
single-quoted case - Ruby does very little, what you type into the single-quoted string literal becomes the string’s value.
double-quoted case - looks for substitutions sequences that start with a backslash character and replaces them with some binary value. \n, which is replaced with a newline character. When you write a string containing a newline to the console, the \n forces a line break.
expression interpolation in double-quoted strings. #{expression} is replaced by the value of expression.
array literal—a set of elements between square brackets
Ruby array indices start at zero

Rails scaffold - auto-generation of a set of a model, views, and a controller usually used for a single database table. scaffold that generates everything that you need (and don't need), models create only some related components


YAML1 is a recursive acronym that stands for YAML Ain’t Markup Language. In the context of Rails, YAML is used as a convenient way to define the configuration of things such as databases, test data, and translations
indentation is important

Marshaling Objects
convert it into a stream of bytes that can be stored outside the application
object can later be read by another instance
copy of the originally saved object can be reconstituted

two potential issues when you use marshalling:
some objects cannot be dumped. If the objects to be dumped include bindings, procedure or method objects, instances of class IO, or singleton objects, or if you try to dump anonymous classes or modules, a TypeError will be raised.
when you load a marshaled object, Ruby needs to know the definition of the class of that object

Rails uses marshaling to store session data.
possible that a particular class may not have been defined at the point it reconstitutes session data
you’ll use the model declaration in your controller to list all models that are marshaled.
This preemptively loads the necessary classes to make marshaling work.

Methods such as empty! and empty?
Ruby method names can end with an exclamation mark (a bang method) or a question mark (a predicate method). Bang methods normally do something destructive to the receiver. 
Predicate methods return true or false depending on some condition.

a || b
The expression a || b evaluates a. 
If it isn’t false or nil, then evaluation stops, and the expression returns a. 
Otherwise, the statement returns b. 
This is a common way of returning a default value if the first value hasn’t been set.

a ||= b
The assignment statement supports a set of shortcuts: a op= b is the same as a = a op b.

obj = self.new
Sometimes a class method needs to create an instance of that class.

lambda
The lambda operator converts a block into an object of type Proc.


require File.expand_path('../../config/environment', __FILE__)
Ruby’s require method loads an external source file into our application.
This is used to include library code and classes that our application relies on.
In normal use, Ruby finds these files by searching in a list of directories, the LOAD_PATH.

use case is simply a statement about how some entity uses a system.




Fixtures - env to run tests
contains YAML

fictures() laods data corresponding to the given model name into the corresponding database before each test method
using :product will call product.yml to be used

this empties the table and populates with row

dev.sql - developement database
test.sqp - test
production.sql - production

concern - tool provided by ActiveSupport for including modules in classes creating mixins.

controller, include - links to concern module to use functions

find_by - streamline where(). returns either line item or nil instead of array

rescue_from - intercepts exception
logger.error - records the error
redirect_to - prevents user from retriggering error

ajax - async javascript and xml

controller x - include module => concern module
include currentcart
before_action - run function

button_to/link_to - remote: true sends AJAX request to the server containing the HTML fragment

format.js - respornd with a format of js, cakks method passing an otional block.
this will look for a template to render wonce function finishes.
this links with a file.js.erb file in the view


setup jquery
jquery-ui-rails - in gem
bundle install
//= require jquery-ui/effects/effect-blind

Helper method - abstract some process our of a view using a helper


CHAPTER 11 F5 p164
important to get name and stream

Action Cable:
1) channel
2) broadcast data
3) receive data

only for localhost
config.action_cable.disable_request_forgery_protection = true


channel/file.coffee

models also stores the array containing fields


atom feeds - take advantage of preexisting clients.
.atom causes rails to look for a template of the functions name

unit testing of models - contains business logic. add product to cart > cart model checks
if product is already in list of items > if so increment quantity, else add new item

functional testing of controllers - controllers direst the show. recieve web requests > 
interact with models to get app state > respond with view to display to user.
when testing controllers, make sure requestes is answered with appropriate response
we need models, but has already covered with unit tests

Test flow of application.
Integration test - simulates a continuous session between one or more virtual users and app.
used to send requrests, monitor responses, follow redirects ...
rails creates the corresponding units or functional tests
Integration, however, are not auto created, but can be generated
integration wanders over the app, so we need to pass a full URL for the controller and action to be invoked



Chapter 15
i18n.rb - internationalization - associates between display names and locale name
html_safe - informs rails the string can be interpreted as html
set translation pack in application controller
within html, convert content with t('.tag')
tag links with .yml file with the same tag


Chapter 17
MODELS
all persistent data retained by the app is managed
five models created: cart, lineitem, order, product, user
default, all models have id, created_at, updated_at attributes.
we added attributes of type string, int, text, decimal, and foreign keys, and a virtual attribute for a password.
has_many/belongs_to relationships used to navigate among our model objects
migrations update the databases to introduce and modify data.
models can be used to actively validate sata, preventinf errors from propagating.
validations for presence, inclusion, numericality, range, uniqueness, format, and confirmation.
custom validation ensures deleted products aren't referenced by any line item.
active record hook ensures admin always remain and used a transaction to roll back incomplete updates on failure.
used logic to add product to cart, add all line itemd from cart to order, encrypt and authenticate password, and compute total
created default sort order for products for display purposes.

VIEW
controls the application presentation to the world.
default, scaffold provides edit, index, new, and show, as wella s partial forms shared between new and edit.
new views were created, admin, sessions, and store.
updated layout to establish a common look of the entire site.
linked stylesheets
used templates to generate javascript, using AJAX and WEBSOCKET for more interactivity.
helper directed when to hide cart from the main view.
localized the customer views for display in english and spanish.
created plain and ATOM views, and for email

CONTROLLER
controllers interacted with the models, from finding and fetching data and putting it into instance variables to update models and saving data entered.
this redirects to action or rendered view in HTML JSON and ATOM.
limited the set of permitted parameters on the line item controller.
created callback actions that were run before selected actions to find the cart, set the language, and authorize requrets.
logic common to a number of concerns
managed sessions, tracking logged users and carts.
tracked current locale used for internationalization
captured errors, logged, and informed users.
emplyed fragmet caching on storefront and page-level caching
sent confirmation emails

CONFIGURATION
conventions keep to a minimum the iamount of configuration required.
modified database configurations.
defined routes for resources, admin, and session controllers, and the root of the site.
defined who_bought of our products resources to access atom feeds
created initializers for i18n putposes and updated locales information for both en and es.
created seed data
created Capistrano script for deplyment, including the definition of a few custom tasks

TESTING
maintained and enhanced test throughout
emplyed unit tests to validation methods
also tested increasing quantity
rails provided basic tests for all units.
tests added fro AJAX and ensuring cart has items.
used fixtures to provide test data to fuel test.
created integration test to end-to-end senarios.


CHAPTER 18
Rails assumes certain runtime directory layout and provides applications and scaffold generators.
rails_app
app - model, view, controller
bin - wrapper scripts
config - configuration and database connection parameters
config.ru - Rack server configuration. configures the Rack Webserver Interafce, to create Metal applciations or use 
Rack middle wares in the rails app. 
db - schema and migration information
gemfile - specifies gem dependencies. also includes the database, web server, and scripts used for deployment.
this is used by the bundler in the config/applications and boot files
gemfile.lock - records versions for the rails applicaitons dependencies. maintained by bundler
lib - shared code
log - log fiels producted by the application
public - web-accessable directory. application runs form here
rakefile - builds script and defines tasks to run test, create documentation, extract the structure of the schema.
Type rake -T prompt for full list. rake -D shows complete description.
readme.md - installation and usage information
test - unit, functional, and integration tests, fixtures, and mocks
tmp - runtime temporary files
vendor - imported code


LIBARIES PLACE
lib holds application code mot in the model, view, or controller.
these are sent directly from the controller to the browser.
you can also place code shared among models, view, or controllers.

LOGS
rails products log information stored in the log directory.
development.log
test.log
production.log
contains trace lines, timing, cache, and expansion of the database statements
file used depends on the environment running.

STATIC WEB PAGES
Public directory is the external face for hte app. 
the web server takes the dir as the base application
placed static files related to running the server

SCRIPT WRAPPERS
wrappers in the bin directory.
use bundle binstubs to populate.
this holds rails scripts when ran using the rails command.
console - interact with the rails application methods
dbconsole - interact with the database
destroy - removes autogenerated files from generate
generate - create controllers, mailers, models, scaffold, and web services.
new - gen rails app
runner - executes method outside the context of the web. used to invoke cache expirt methods
server - runs rails app in self-contained web server

TEMPORARY FILES
tmp dir
subdirectories for cache contents, sessions, and sockets.
cleaned up by rails but may need to check.

THIRD-PARTY CODE
vendor dir
install rails with dependencies in the vendor dir.
delete vendor/cache to use system-wide version

CONFIGURATION
config dir
rails executes config/environment and application.rb/
the standard env setup automatically in the load path.
app/controllers dir and subdir
app/models dir
vendor and lib dir contained in each plugin subdir
dir app, helpers, mailers, and concerns
rails will load per-environment configuration file in the env dir.
the switch that dictaes the runtime is external to the app
no app code needs to be changed from dev>test>prod
use rails server -e (development/test/production) to change servers
you can also create your own environment
add new section to the database config

NAMING CONVENTIONS
MIXED CASE,UNDERSCORE,PLURALS
variables and classes in short phrases
varaibles in lowercase and seperated by underscore
classes and modules is capitalized with no undersoce
rails uses these and assumes database tables also have lowercase, and tables are always plural.
Rails assumes files are named using lowercase with underscore
naming conventions are used automatically to convert names
app contains model class line items defined as LineItem
rails automatically decuces
    a corresponding database table with line_items
    a class definition called line_item.rb
controllers has a diff naming conventions, store controller:
    class called StoreController with finr name store_controller.rb
    HelperModule StoreHelper in the store_helper.rb
    view templates in the views/store
    default take the output of the view and wrap them in the layout template in the store.html.erb dir
require is generally used to include ruby source files before class reference
since rails knows the relationship, require is not needed.
when referencing a unknown class, rails uses naming conventions to convert class name to file to load behind the scenes.
typically reference the name of the model class automatically loaded to the application

GROUPING CONTROLLERS INTO MODULES
you can add more structure to the controllers, but may end up with controllers performing disjointed functions.
we can group them into a single admin namespace.
Rails uses simple naming conventions.
admin/book > book_controller > app/controllers/admin
always resolve to {name}_controller
if there were a book controller in two places (admin/content) both will define BookController and clash.
therefore, rails assumes subdirectoriesof rht app/controller are modules named after subdirectory.
thus declared differently:
    Admin::BookController
    Content::BookController
therefore splits inside the application.
templates appear in subdirectories of app/view.
    http://my.app/admin/book/edir/1234
    app/view/admin/book/edit.htl.erb


---------------------------------------------------------------
CHAPTER 19 - ACTIVE RECORD
Active Record = object-relational mapping layer

DEFINING DATA
defined a number of models with attributes, such as email in a string.
rails provides a id containing the primary key for the record and additional attributes to track time.
rails support relationships between models such as orders and line items.

ORGANIZING TABLES AND COLUMNS
each subclass of ApplicationRecord, such as Order, wraps a seperate database table.
active record assumes name of the table associated with a given class is the plural form of the class name.
if name contains multiple capitalized words, table name is assumed to have underscores between words.
    Order > orders
    TaxAgency > tax_agencies
    Person > people
these rules reflect rails philosophy that class names should be singular, and tables plural.
sometimes may not be handled correctly.
add to rails understanding of the idiosyncrasise by modifying config/initializers/inflections.rb, inflect.irregular
in legacy tables, you can control the name with self.table_name
Active record classes correspond to rows in a database table.
objects have attributes correspondingto teh columns in the table.
class order didnt mention any columns in hte orders table.
active record determines them dynamically.
this reflects the schema inside the database to configure the classes that wrap tables.
setting value of an attribute does not change anything in the database.
we must save the object for this change to become permanent.
value returned is cast by ACtive Record to an appropriate ruby type.
append _before_type_cast to get raw value.

ADDITIONAL COLUMNS PROVIDED BY ACTIVE RECORD
column names has significance to active record:
    created_at, created_on, updated_at, updated_on - 
    automatically updated. ensure underlying database column is compatable. rails uses _on and _at to include time
    id - default name of primay key
    xxx_id - default name of foreign key ref to xxx table
    xxx_count - counter cache for child table xxx


LOCATING AND TRAVERSING RECORDS
LineItem has a direct relation to cart, order, and product.
models has indirect relationship mediated by resource object
relationship between orders and products through line itens is an example.

IDENTIFYING INDIVIDUAL ROWS
Active record classes corresponds to tabels in a database.
instances corresponds to individual rows in a database table.
For new schemas, id for all tables is preferable.
however for existing schemas active record allows overriding the name.
    self.primary_key
AR takes care of creating primary key values for records created and add to the database.
if we override primary key, we need to set the key to a unique value before we save. 
we still set an id to do this.
primary_key= declares name of column to use in the table. 
when you need to set the primary key, use id, else use actual column name.
mdoel objects also redefine ruby id() andhash() to ref primary key.
unsaved model objects cannot reliably be used as hash keys.
rails considers two model objects as equal if instances of the same class has the same primary key.
therefore, unsaved model objects may compare as equal even with different attribute data.

SPECIFYING RELATIONSHIPS IN MODELS
AR supports 3 types of relationship between  tables:
    1-to-1 - is implemented using a foriegn key in one row in one table to reference a single row. 
    might exist between orders and invoices. model for the table containing foreign key always has belongs_to
    1-to-many - represents collection of objects. number of associated line items. 
    AR, parent object containing collection of child objects, uses has_many and child uses belongs_to
    many-to-many - use has_and_belongs_to_many, association is symetrical. 
    rails implements using an intermediate join containing foreign keys. AR assumes concatenation.
indicate:
    has_one
    has_many
    belongs_to
    has_and_belongs_to_many


CREATING, READING, UPDATING AND DELETING (CRUD)
CREATING NEW ROWS
create new objects in table by calling Table.new(), and fill with attributes.
need to call save() to store back to database.
AR constructors take an optional block.
invoked with newly created order as a parameter.
useful if you wanted to create and save an order without creating a new variable.
AR constructors accpts hash of attribute vlaue as an optional parameter.
each entry corresponds to name and vlaue of an attribute.
useful for sorting things like storing values.
AR default sets an integer for primary key.
new() creates object in memory and needs to save in database.
.create() uses both new() and save()
create() can pass arrays to store multiple information.
using hash values allows you to construct model objects from form parameters

READING EXISTING ROWS
first specify row of data by giving AR a criteria to return a object.
use primary key
every model class has find()
given one primary key, find() returns an array.
RecordNotFound exception is raised on error
often, read rows based on criteria other than primary key.
AR provides additional methods to express more complex queries.

SQL AND ACTIVE RECORD
AR works with SQL passing simple stings to where()
dont use variable #{x} due to injection attack.
if we pass multiple parameters to a where() call, rails treats first parameter as a template
we can embed placeholders (:name) to replace values in the array. done by inserting question marks.
or pass full order params[:order]

USING LIKE CLAUSES
rails doesnt parse SQL inside condition and doesn't know the name is being substituted into a string.
need to pass the full parameter and parameter

SUBSETTING THE RECORDS RETURNED
ActiveRecord::Relation, first() and all()
to_a() - returns rows as array
query is not evaluated unless the method is used
this allows us to modify the query by alling additional methods.
    .order - add order by to specify the criteria normally add after order by.
    .limit - linit the number of rows returned. when used, also specify order for consistency.
    .offset - specify offset of the first row results. 
    .select - select limits values returned if only a subset is needed.
    .joins - specify a list of addiitional tables to be joined. inserted after name and before any conditions.
    .readonly - return objects that cannot be stored back in database.
    .group - group items
    .lock - takes optional string. should be a SQL fragment that specifies a lock. share mode gives latest data in row and gurantees.
    database default exclusive lock is obtained. transactions eliminate the use of locks.

GETTING COLUMN STATISTICS
statistics can be given using .average, .maximum, .minimum etc.
these corresponds to aggregate functions in the underlying database and can be combined with methods.
returns a single value by default.
However, with group method, products a series for each set of records.
this returns a hash.
you can iterate over entries in order.
this is no longer database independent.

SCOPES
making chains themselves for reuse becomes a concern.
AR scope can be associated with a Proc and have arguments.
scopes makes application code easier to write and read, and more efficent
scopes can bu used for any condition, however only limited to one clause

WRITING OUR OWN SQL
each method contributes to teh construction of a full SQL query string.
find_by_sql() accepts a parameter containing a select statement and returns an array
only attributes returned by query will be avalible in the resulting model.
the first returns a hash of attributes name-value pairs
second, name
third, true
find_by_sql can be used to craete model objects contraining derived column data.
XXX syntax give derived column, a name in the result set.
we can pass an array where the first element is a string conmtaining placeholders and the rest as hash.

RELOADING DATA
from multiple access, fetched model may be outdated.
you need to refresh a model manually.
AR calls reload()

UPDATING EXISTING ROWS
you can write to the database using save()
if object previously read, the save will update existing row, else insert new row
primary key column will match with in-memory object.
attributes contrained determin the columns that is updated only if value is changed.
in addition to save(), AR lets us change the values of attributes and save a model object ijn a single call to update().
update() is used in controller actions merging data from a from to database row.
we can combine functions of reading a row and updating using class methods update() and update_all().
update() take id parameter and a set of attributes.
it fetches the corresponding row, updates and attributes, saves the result and returns the model object.
pass update() an array of IDs and an array of attribute value hashes to update all corresponding rows.
update_all class allows us to specify the set and where clauses of the SQL update statement.
update_all depends on the database adapter.

!!
save returns true if record was saved, else nil
save! returns true of save succeeded, else error exception
create returns AR object regaradless of success or fail. check object for validation errors to determine if written.
create! returns AR object on success, else error exception

DELETING ROWS
AR support two styles of row deletion.
    delete() - takes single ID or array and deleted corresponding rows.
    delete_all() - delete rows given condition, or all rows.
return values depend on the adapter.
destrot methods are the second form via AR object.
    destroy() - deletes from the database corresponding to model object. freezes object preventing changes
both methods read the corresponding rows and call instance-level destroy
delete bypasses various AR callback and validation, while destroy ensure they are invoked.
better to use destroy to ensure database is consitent

PARTICIPATING IN THE MONITORING PROCESS
AR controls the life cycle of model objects.
using callbacks, AR lets the code participate in monitoring process.
callback can perform complex validation, map column values as passed in and out of the database.
    before/after_validation - accepts on: :create or :update which causes the callback to be called only on the selected operation.
    after_find - invokes after any find operation
    after_initialize - invoked after AR model object is created
to execute callback, write handler and associate with appropriate callback.
prefered way is to declare handler as a method or block.
associate handler with particulat event using class methods after the event.
to associate method, declare as private or protected, and specify name as a symbol.
to specify block, add after declaration
you can specify multiple handlers for the same callback that will generally invoke in order specified.
you can define callback instacne methods using callback objects, inline methods, or inline eval methods.

GROUPING RELATED CALLBACKS TOGETHER
convienient to group into seperate handlers.
these can be shared between multiple models.
handler class is simply a class that defines callback methods.
model object that uses handlers, create an instance if this handler class and pass that instance to the various callback declarations.
handler needsd to encrypt a given set of attributes in a model before the models data is written.
callbacks are good but can sometimes result iun a model class taking responsibility, not related to the model.

TRANSACTIONS
transaction groups a series of changes that either the database applies all the changes or applies non.
withiin transaction, every SQL statement succeeds or have no effect.
if any sttatement fails, entire transaction has no effect on the database
AR use transaction() to execute block in the context of a database transaction
at the end of a block, transaction is committed, updating the database unless exception is raised and rolled back.
because transaction exist in database connection, we invoke with AR receiver

Passing Parameters
method(param_name: params[:url_param])

BUILT-IN TRANSACTIONS
AR takes care of saving all dependent child rows when you save parent row.
takes multiple SQL statement execution
change should be atomic






RAKE SCHEDULE

schedule.rb - set time task
create rake file in lib/tasks/scheduled


